// do not forget to put .js in Nodejs
npm init -y  >> Create Package.json
npm i express >> to install express
create index.js to create main application

import express from "express"
const express = require("express)

in Package json file add one line "type": "module" to use es6 import export
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module"
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },

To run the application we should first import express and then define the post app.listen(8800)

testscript if server has started 
app.listen(8800 ,()=>{
    console.log("connected to backend with Nodemon wathcher")
})

To start our server need to make following changes into package json start script

"scripts": {
    "start": "node index.js"
  },
so when you do npm start our server will be started at localhost:8800

but we would not want to restart server after making any changes therefore we can install nodemon

npm i nodemon then change in package jason
"scripts": {
    "start": "node index.js" to "nodemon index.js"
    npm start 

connect to the mangodb cluster copy url

npm i dotenv 

and create a .env file and paste mongodn url with username and password

MONGO = mongodb+srv://kakashi:<password>@cluster0.z4oft.mongodb.net/?retryWrites=true&w=majority

<password> put your password  in env file and save

install mongooose 

// How an API works  here / represent the endpoint the main url of the website on the server
//req : what user is requesting
//res: what we are sending to the user

app.get("/",(req,res)=>{
    res.send(500) // Internal Server Error
})

suppose if user wants to login we can redirect him to /users endpoint and define what must be done at tha end point via API

app.get("/users",(req,res)=>{
    res.send(500) // Internal Server Error
})

since there may be many routes better to create them in another folder and run as a seperate app inside main app
if you are importing any file do not forget to put .js in import section import authRoute from "./api/routes/auth.js"

//middlewares
app.use("/auth",authRoute)

so this is how we use middlewares if anyone come to auth it will be move to authRoute which will direct them to auth.js where actual endpoint exist

http://localhost:8800/auth
Hello this is auth endpoint

router.get("/",(req,res)=>{
    res.send("Hello this is auth endpoint")
})

router.get("/register",(req,res)=>{
    res.send("Hello, this is auth register endpoint")
})

export default router

http://localhost:8800/auth/register
Hello, this is auth register endpoint

then we need to create Schema for our Database so we create a folder name models and defined schema into it
models >>
Hotel.js  >> Import schema take schema import from mongoose site and paste create object and export then create function and try catch methods in Route hotels
Rooom.js
Users.js


//CREATE
router.post("/",async (req,res)=>{  // post > to create
  try{

  }catch(err){
    res.status(500).json(err)
  }
})

But we are going to handle here with Middleware. its just for beginers how to make a real request

//CREATE
router.post("/",async (req,res)=>{ 
  try{

    const newHotel = new Hotel(req.body)  // req is what we are taking from users it can be anything as after /:id parameter, or we can take any query/?limit=5 or we can take body

What is insomnia and how does it work?
Insomnia started as an HTTP client, just like Postman itself, and evolved to a tool for API development. It offers an HTTP client, automated API testing, and an Open API editor. You can send requests to both local & deployed APIs, define multiple environments, and embed environment variables to your requests.

Insomnia REST Client and Postman can be categorized as "API" tools.

Insomnia REST Client is an open source tool with 10.2K GitHub stars and 590 GitHub forks. Here's a link to Insomnia REST Client's open source repository on GitHub.
https://stackshare.io/stackups/insomnia-rest-client-vs-postman

import Hotel from "../models/Hotel.js";  // Sticly follow .js when we are importing

in insomnia client make a new Post request with JSON file for body and test
localhost:8800/api/hotels  enter the json and url and click send check if there are any errors

we got an error here because we needed to define a middleware here app.use(express.json())
app.use(express.json())

app.use(express.json()) // What Does `app.use(express.json())` Do in Express?
//The app.use() function adds a new middleware to the app. Essentially, whenever a request hits your backend, Express will execute the functions you passed to app.use() 

//express.json() is a built in middleware function in Express starting from v4.16.0. It parses incoming JSON requests and puts the parsed data in req.body.

once your data is correct in  Insomnia REST Client Post then check Mongo DB browse it will create your DB there


Post : localhost:8800/api/hotels

{
	"name":"Hotel Aravali",
	"type":"hotel",
	"city":"Aburoad",
	"address":"somewhere",
	"distance":"500",
	"title":"Best Hotel in the City",
	"desc":"Veg and Bar Restaurent",
	"cheapestPrice":100
}

PREVIEW IN API CLIENT 
{
	"name": "Hotel Aravali",
	"type": "hotel",
	"city": "Aburoad",
	"address": "somewhere",
	"distance": "500",
	"photos": [],
	"desc": "Veg and Bar Restaurent",
	"rooms": [],
	"cheapestPrice": 100,
	"_id": "62e88f2b56a68e1cad86ef27",
	"__v": 0
}

HERE ID GENERATED IS USED TO UPDATE THE RECORD
when we update the method and click send Mango DB is updated with new field but json shows old entery show we can add {new: true}

{
	"name":"Jay Ambe"
}

{
	"_id": "62e88f2b56a68e1cad86ef27",
	"name": "Hotel Aravali",
	"type": "hotel",
	"city": "Aburoad",
	"address": "somewhere",
	"distance": "500",
	"photos": [],
	"desc": "Veg and Bar Restaurent",
	"rooms": [],
	"cheapestPrice": 100,
	"__v": 0
}

but check MangoDB its updated with new entery

Express.js is a routing and Middleware framework for handling the different routing of the webpage and it works between the request and response cycle. 
Middleware gets executed after the server receives the request and before the controller actions send the response. 
Middleware has the access to the request object, responses object, and next, it can process the request before the server send a response. 
An Express-based application is a series of middleware function calls.
https://www.geeksforgeeks.org/middleware-in-express-js/


how to handle errors in express node

// Another middleware
app.use((req,res,next)=>{  // next is a callback function here
	console.log("I am middleware!");
  })

  //GET ALL

router.get("/", async (req,res,next)=>{

    console.log("HI I am a Hotel Root")
   return next();  // do not forget to use return while calling a callback function sent from middleware
    
    try{
         const hotels = await Hotel.find();
         
    res.status(200).json(hotels);
    } catch (err){
        res.status(500).json(err);
    }
}); 


connected to mangodb

HI I am a Hotel Root
I am middleware!

//GET ALL

router.get("/", async (req,res,next)=>{

  console.log("HI I am a Hotel Root")
  return next();

  app.use((req,res,next)=>{  // next is a callback function here
    res.send("Hello I am middleware!");
    })
// Error Handling middleware
// next is a callback function here if error occurs on any API request on any root we will
//  handle this error we must pass all 4 parameters otherwise it will not work

app.use((err,req,res,next)=>{  
  return res.status(500).json("Hello Error from Handler")
  })    
=================
app.use((err,req,res,next)=>{  // next is a callback function here if error occurs on any API request on any root we will handle this error we must pass all 4 parameters otherwise it will not work
  const errorStatus = err.status || 500 ;
  const errorMessage = err.message || "Something went Wrong";
  return res.status(errorStatus).json({
    success:false,
    status:errorStatus,
    message:errorMessage,
    stack:err.stack,
  }
=================================
router.get("/", async (req,res,next)=>{

  const failed = true;
  const err = new Error();
  err.status = 404;
  err.message = "Sorry not Found!";
  if(failed) return next(err);

  try{
       const hotels = await Hotel.find(); // for test the error message findById("asdasdadsa");
       
  res.status(200).json(hotels);
  } catch (err){
      next(err)
  }

=============================

create Error in a seperate file utils>error.js and created Error function therefore

router.get("/", async (req,res,next)=>{

  const failed = true;
  if(failed) return next(createError(401,"You are not authenticated"));

  try{
       const hotels = await Hotel.find(); // for test the error message findById("asdasdadsa");
       
  res.status(200).json(hotels);
  } catch (err){
      next(err)
  }
});


In order to create a controller like updating hotels register authenticate user we should have a Model on which we perform operations
where we will create update delete data

in Route auth create a post function for user creation which point to register methods sits in authcontroller
create a post method in insomianc and test user

localhost:8800/api/auth/register
{
	"username": "Lavesh",
	"email": "lavesh@gmail.com",
	"password": "12345"
}
User has been created
check MangoDB for new user schema in DB which newly created user 

as our password is visible in DB so encrpt that password in the db as well we need one more library which is bycrpt
======================
create and login function initial


import User from '../models/User.js';
import bcrypt from "bcryptjs"
import { createError } from "../utils/error.js"

// CREATE NEW USER

export const register = async(req,res,next)=>{
    try{
        //To hash a password: 
        const salt = bcrypt.genSaltSync(10);
        const hash = bcrypt.hashSync(req.body.password, salt);

        const newUser = new User({
            username:req.body.username,
            email:req.body.email,
            password:hash,
        });

        await newUser.save()
        res.status(200).send("User has been created")
    }catch(err){
    next(err)
    }
}


//LOGIN FUNCTION

export const login = async(req,res,next)=>{
    try{
        const user = await User.findOne({username:req.body.username})
        //creating custom error below if user not found
        if(!user) return next(createError(404,"User not found!."))

        const isPasswordCorrect = await bcrypt.compare(req.body.password,user.password)
        if(!isPasswordCorrect) return next(createError(400,"Wrong Password or username!"))
        // this sends userback the password and isAdmin details to prevent this we will destructure the details of user and send only required details

        const {password, isAdmin, ...otherDetails} = user._doc; 

        res.status(200).json({...otherDetails})
    }catch(err){
    next(err)
    }
}
========================

What is a JWT token?
A JSON Web Token (JWT) is an access token standardized according to RFC 7519, 
which makes it possible for two parties to securely exchange data. It contains 
all important information about an entity, meaning that no database queries 
are necessary and the session doesnâ€™t need to be saved on the server.

JWTs or JSON Web Tokens are most commonly used to identify an authenticated user. 
They are issued by an authentication server and are consumed by the client-server (to secure its APIs).
https://hackernoon.com/what-is-a-json-web-token-jwt

install jwt 

npm install jsonwebtoken 
it will check what data needs to be send to user what type of user is about to login Admin or normal user 
import jwt from "jasonwebtoken";
https://medium.com/swlh/all-you-need-to-know-about-json-web-token-jwt-8a5d6131157f
https://generate.plus/en/hex/secret-key

store secret key for JWT in env file and call it by process.env.JWT where you wanna call 

const token = jwt.sign({id:user.id, isAdmin:user.isAdmin}, process.env.JWT); // set this token to cookies for that we need to install cookie parser
npm i cookie-parser
//also we need to import cookieparser as middleware
import cookieParser from "cookie-parser";

once code implemented success you can check for access token in indominiac cookie tab
access_token	eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjYyZWEyN2ExZmM3MWNhMDFkMWQ2NTk5MSIsImlzQWRtaW4iOmZhbHNlLCJpYXQiOjE2NTk1NDYwOTF9.bRKpXsO3yolrT4CW01mSdXiBrVY_p7vPEPuB6J8dxXY

localhost:8800/api/users/checkauthentication

FOR DELETE ROOM METHOD WE WILL USE BOTH ROOM AND HOTEL ID 
localhost:8800/api/rooms/62eb2e0e179ece036cf1323b/62e9e9dc88188aff08f32ed6

when room created you can check in getall hotels rooms and room id 
"rooms": [
  "62eb3170179ece036cf1324f"
]

to get all hotels by cities and type create 2 more routes and then controller
in the insomniac create a query ? in URL
localhost:8800/api/hotels/countbyCity?cities=berlin,madrid,london

To fetch the user items we are going to use Axios

also create a useFetch hooks in client UI to fetch data 
use Proxy if dont then install cors middleware in backend API
